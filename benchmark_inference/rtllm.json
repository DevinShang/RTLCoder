{"Instruction": "Please act as a professional verilog designer.\n\nImplement a module to achieve serial input data accumulation output, input input 8bit data, whenever the module receives 4 input data, the output outputs 4 received data accumulation results. The input and output interfaces interact with the upstream and downstream using the valid-ready two-way handshake mechanism. When both upstream and downstream are required to be able to transmit at full speed, there is no bubble in data transmission, and no additional performance loss can be caused due to the design of this module.", "Input": "module accu(\n    input               clk         ,   \n    input               rst_n       ,\n    input       [7:0]   data_in     ,\n    input               valid_a     ,\n    input               ready_b     ,\n \n    output              ready_a     ,\n    output  reg         valid_b     ,\n    output  reg [9:0]   data_out\n);"}
{"Instruction": "Please act as a professional verilog designer.\n\nImplement a module of an 8 bit adder in gate level.", "Input": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, output [7:0] sum, \n    output SUM, \n    output cout);"}
{"Instruction": "Please act as a professional verilog designer.\n\nImplement a module of a 16-bit full adder.", "Input": "module adder_16bit(\n    input   wire    [15:0]  a,\n    input   wire    [15:0]  b,\n    input   wire            c_up,\n    \n    output wire     [15:0]  y,\n    output wire             Co\n);"}
{"Instruction": "Please act as a professional verilog designer.\n\nImplement a module of a carry lookahead 32 bit adder based on CLAs.", "Input": "module adder_32bit(A,B,S,C32);\n     input [32:1] A;\n     input [32:1] B;\n     output [32:1] S;\n     output C32;"}
{"Instruction": "Please act as a professional verilog designer.\n\nImplement an asynchronous FIFO, FIFO bit width and depth can be configured(parameter DEPTH = 16,parameter WIDTH = 8). The asynchronous FIFO structure is divided into several parts. The first part is dual-port RAM, which is used for data storage. Instantiate dual-port RAM as a submodule, The RAM ports are input wclk,input wenc,input [$clog2(DEPTH)-1:0] waddr,input [WIDTH-1:0] wdata,input rclk,input renc,input [$clog2(DEPTH)-1:0] raddr,output reg [WIDTH-1:0] rdata. The second part is the data write controller. The third part is the data read controller. The fourth part is the read pointer synchronizer. The read pointer is collected using the two-stage trigger of the write clock and output to the data write controller. The fifth part is the write pointer synchronizer, which uses the two-stage trigger of the read clock to collect the write pointer and output it to the data read controller.\nThe method of empty and full judgment is to generate empty and full signal by comparing Gray code. Use 4-bit Gray code as a read/write pointer for a FIFO with depth 8. The gray code is converted to a four-digit binary number, using the lower three digits of the binary number as the address to access RAM. When the read and write Pointers are equal, the FIFO is null.\nWhen the write pointer has one more cycle RAM than the read pointer, the highest and second-highest bits of the read and write pointer are opposite, the remaining bits are the same, and the FIFO is full.", "Input": "module asyn_fifo#(\n\tparameter\tWIDTH = 8,\n\tparameter \tDEPTH = 16\n)(\n\tinput \t\t\t\t\twclk\t, \n\tinput \t\t\t\t\trclk\t,   \n\tinput \t\t\t\t\twrstn\t,\n\tinput\t\t\t\t\trrstn\t,\n\tinput \t\t\t\t\twinc\t,\n\tinput \t\t\t \t\trinc\t,\n\tinput \t\t[WIDTH-1:0]\twdata\t,\n\n\toutput wire\t\t\t\twfull\t,\n\toutput wire\t\t\t\trempty\t,\n\toutput wire [WIDTH-1:0]\trdata\n);\n\nparameter ADDR_WIDTH = $clog2(DEPTH);"}
{"Instruction": "Please act as a professional verilog designer.\n\nImplement a module of perpetual calendar. The output port Secs counts from 0 to 59, and when the Secs count reaches 59, the output port Mins increases by one and stops counting until minute=59. When the Mins count reaches 59, the output port Hours increases by one and stops counting until Hours=24.", "Input": "module calendar(CLK,RST,Hours,Mins,Secs);\ninput CLK,RST;\noutput [5:0] Hours,Mins,Secs;"}
{"Instruction": "Please act as a professional verilog designer.\n\nImplement a module of a counter design that requires counting from 4 'b0000 to 4' d12. The counting can be controlled by the input signal valid_count. That is, the count is paused if valid_count is invalid.", "Input": "module counter_12(\n    input rst_n,\n\tinput clk,\n\tinput valid_count, \n\toutput [3:0] out\n\t);"}
{"Instruction": "Please act as a professional verilog designer.\n\nImplement a module for edge detection, there is a slowly changing 1 bit signal a. When the rising edge of signal a is detected, the indicating signal rise is given; when the falling edge of signal A is shown, the indicating signal down is given. rise and down are high on the next clock when the corresponding edge appears, and then return to 0 until the corresponding edge appears again.", "Input": "`timescale 1ns/1ns\nmodule edge_detect(\n\tinput clk,\n\tinput rst_n,\n\tinput a,\n\t\n\toutput reg rise,\n\toutput reg down\n);"}
{"Instruction": "Please act as a professional verilog designer.\n\nImplement a frequency divider that the input clock frequency of 100MHz signal, and the outputs are 3 clock frequencies: 50MHz, 10MHz, 1MHz.", "Input": "module freq_div (CLK_in,CLK_50,CLK_10,CLK_1,RST);\ninput CLK_in,RST;\noutput reg CLK_50,CLK_10,CLK_1;"}
{"Instruction": "Please act as a professional verilog designer.\n\nImplement a FSM detection circuit that detects a single bit input IN. When the input is 10011, output MATCH is high, and MATCH is 0 in other cases.", "Input": "module fsm(IN,MATCH,CLK,RST);\ninput IN,CLK,RST;\noutput reg MATCH;\n\nreg [2:0] ST_cr,ST_nt;\n\nparameter s0 = 3'b000;\nparameter s1 = 3'b001;\nparameter s2 = 3'b010;\nparameter s3 = 3'b011;\nparameter s4 = 3'b100;\nparameter s5 = 3'b101;"}
{"Instruction": "Please act as a professional verilog designer.\n\nImplement a 64-bit Johnson counter (torsional ring counter), and cyclic state of the the similar 4-bit Johnson counter is as follows: 0000, 1000, 1100, 1110, 1111, 0111, 0011, 0001, 0000.", "Input": "`timescale 1ns/1ns\n\nmodule Johnson_Counter(\n   input                clk ,\n   input                rst_n,\n \n   output reg [63:0]     Q  \n);"}
{"Instruction": "Please act as a professional verilog designer.\n\nImplement an 8bit booth-4 multiplier. The module contains the following internal signals and registers:\n\np: 16-bit register to store the product\nmultiplier: 16-bit register to store the multiplier value\nmultiplicand: 16-bit register to store the multiplicand value\nrdy: Ready signal register indicating the completion of the multiplication operation\nctr: 5-bit counter to keep track of the current bit position being processed in the multiplier\nThe module uses an always block sensitive to the positive edge of the clock signal (posedge clk) and the positive edge of the reset signal (posedge reset). Inside the always block, the behavior of the module is defined as follows:\n\nDuring the reset condition (reset signal is high), the module initializes the registers and signals:\n\nrdy is set to 0 to indicate that the multiplication operation is not yet complete.\np is set to 0 to clear the product register.\nctr is set to 0 to reset the counter.\nmultiplier is set to the sign-extended value of the a input, where the most significant bit of a is replicated to the left 8 bits of multiplier.\nmultiplicand is set to the sign-extended value of the b input, where the most significant bit of b is replicated to the left 8 bits of multiplicand.\nDuring the non-reset condition, the module performs the Booth multiplication algorithm:\n\nIf the counter ctr is less than 16, the module shifts the multiplicand register to the left by 1 bit (multiplicand <= multiplicand << 1).\nIf the current bit of the multiplier at position ctr is 1, the module adds the shifted multiplicand to the p register (p <= p + multiplicand).\nThe counter ctr is incremented by 1 in each clock cycle.\nOnce the counter ctr reaches 16, the multiplication operation is complete, and the rdy signal is set to 1 to indicate readiness.\n", "Input": "`timescale 1ns / 1ps\n\nmodule multi_booth (p, rdy, clk, reset, a, b);\n   input clk, reset;\n   input [7:0] a, b;\n   output [15:0] p;\n   output rdy;"}
{"Instruction": "Please act as a professional verilog designer.\n\nImplement the design of 4bit unsigned number pipeline multiplier. ", "Input": "`timescale 1ns/1ns\n\nmodule multi_pipe_4bit#(\n\tparameter size = 4\n)(\n\tinput \t\t\t\t\t\tclk \t\t,   \n\tinput \t\t\t\t\t\trst_n\t\t,\n\tinput\t[size-1:0]\t\t\tmul_a\t\t,\n\tinput\t[size-1:0]\t\t\tmul_b\t\t,\n \n \toutput\treg\t[size*2-1:0]\tmul_out\t\t\n);\n    //parameter \n    parameter N = size * 2;"}
{"Instruction": "Please act as a professional verilog designer.\n\nImplement a multi-bit MUX synchronizer, data_in will remain constant during the period when data_en is high, and data_en is high for at least 3 B clock cycles. When the value of data_en is high, data can be synchronized. The data change frequency of data_in is very low. The change interval between two adjacent data is at least 10 B clock cycles.", "Input": "module mux(\n\tinput \t\t\t\tclk_a\t, \n\tinput \t\t\t\tclk_b\t,   \n\tinput \t\t\t\tarstn\t,\n\tinput\t\t\t\tbrstn   ,\n\tinput\t\t[3:0]\tdata_in\t,\n\tinput               data_en ,\n\n\toutput reg  [3:0] \tdataout\n);"}
{"Instruction": "Please act as a professional verilog designer.\n\nImplement a module for parallel-to-serial conversion, where every four input bits are converted to one output bit. The output signal valid_in indicates the validity of the input at that time. ", "Input": "`timescale 1ns/1ns\nmodule parallel2serial(\n\tinput wire clk  ,\n\tinput wire rst  ,\n\tinput wire [3:0]d ,\n\toutput wire valid_in ,\n\toutput wire dout\n\t);"}
{"Instruction": "Please act as a professional verilog designer.\n\nImplement the design where a single clock-cycle width pulse(data_in) is extracted from the A clock(fast) domain and a new single clock-width pulse (data_out) will be created in the clock domain B(slow). The frequency of clock domain A is 10 times that of clock domain B.", "Input": "`timescale 1ns/1ns\n\nmodule pulse_detect(\n\tinput \t\t\t\tclk_fast\t, \n\tinput \t\t\t\tclk_slow\t,   \n\tinput \t\t\t\trst_n\t\t,\n\tinput\t\t\t\tdata_in\t\t,\n\n\toutput  \t\t \tdataout\n);"}
{"Instruction": "Please act as a professional verilog designer.\n\nImplement a radix-2 divider module and the inputs are two 8-bit operands. \nThe registers remainder_reg, divisor_reg, and quotient_reg are used to store the current values of the remainder, divisor, and quotient, respectively. i is a 4-bit counter for the iterations.\n\nInside the always block, the code handles the initialization when rst_n is low. It sets the remainder_reg to the value of dividend, divisor_reg to the value of divisor, and quotient_reg to 0.\n\nIn the else block (when rst_n is high), the radix-2 division algorithm is executed.\n\nThe code performs four iterations to calculate the quotient and remainder. Each iteration checks if the remainder_reg is greater than or equal to a shifted version of the divisor_reg concatenated with zeros. If it is, the corresponding bit of the quotient is set to 1, and the remainder_reg is updated by subtracting the shifted divisor. Otherwise, the corresponding bit of the quotient is set to 0.\n\nAfter each iteration, the bits of the quotient are shifted down by 4 positions to prepare for the next iteration.\n\nThe final quotient and remainder values are assigned to the output ports quotient and remainder, respectively.", "Input": "module radix2_div(\n    input \t\t\t[7:0]  \t\tdividend \t,  \t\t\n    input \t\t\t[7:0]  \t\tdivisor \t,   \t\n    input\t\t\t\t\t\tclk \t \t,\t \t\n    input                       rst_n       ,       \n    output wire \t\t[7:0] \tquotient \t,  \t\t\n    output wire \t\t[7:0] \tremainder  \t\t\t\n);"}
{"Instruction": "Please act as a professional verilog designer.\n\nImplement a true dual-port RAM with a depth of 8 and a bit width of 4 bits, with all data initialized to 0000. It has two groups of ports, respectively for reading data and writing data, and read and write operations can be carried out at the same time. When the read_en signal is valid, the read_data of the corresponding position is read through the read_addr signal and output; When the write_en signal is valid, data is written to the corresponding position through the write_addr signal and write-data signal.", "Input": "module RAM (\n\tinput clk,\n\tinput rst_n,\n\t\n\tinput write_en,\n\tinput [7:0]write_addr,\n\tinput [5:0]write_data,\n\t\n\tinput read_en,\n\tinput [7:0]read_addr,\n\toutput reg [5:0]read_data\n);\n    //prameter \n    parameter WIDTH = 6;\n    parameter DEPTH = 8;"}
{"Instruction": "Please act as a professional verilog designer.\n\nImplement a right shifter. The module performs an 8-bit right shift on a 1-bit input by first initializing the q register to 0. On each rising edge of the clock, the module shifts the contents of the q register to the right by one bit and inserts the new input bit d into the most significant position of the register.The register is defined as reg [7:0] q and initialized to 0 using the initial statement. The value of q is right-shifted by 1 bit using the >> operator: q <= (q >> 1).The most significant bit (q[7]) of the register is assigned the value of the input signal (d): q[7] <= d.", "Input": "module right_shifter(input clk, input d, output  [7:0] q);"}
{"Instruction": "Please act as a professional verilog designer.\n\nImplement a series-parallel conversion circuit, the input end inputs single bit data, and when the module receives 6 input data, the output end outputs the 6bit data after splicing. The module adopts the valid-ready two-way handshake mechanism between the input and upstream, and the valid-only handshake mechanism between the output and downstream. During data concatenation, the received data is placed in the lower part of data_b. ", "Input": "\nmodule serial2parallel(\n    input               clk         ,   \n    input               rst_n       ,\n    input               valid_a     ,\n    input               data_a      ,\n \n    output  reg            ready_a     ,\n    output  reg         valid_b     ,\n    output      [5:0]   data_b\n);"}
{"Instruction": "Please act as a professional verilog designer.\n\nImplement a signal generator module, select the signal wave_choise according to the waveform to send out the corresponding waveform: wave_choice=0, send out the square wave signal; wave_choice=1, sends a sawtooth signal; wave_choice=2, the triangular wave signal is emitted. ", "Input": "`timescale 1ns/1ns\nmodule signal_generator(\n\tinput clk,\n\tinput rst_n,\n\tinput [1:0] wave_choise,\n\toutput reg [4:0]wave\n\t);"}
{"Instruction": "Please act as a professional verilog designer.\n\nImplement a traffic light, with red, yellow and green three small indicators and a pedestrian button, under normal circumstances, the motor vehicle lane indicator light according to 60 clock cycles of green, 5 clock cycles of yellow, 10 clock cycles of red. When the pedestrian button is pressed, if the remaining green time is greater than 10 clocks, it is shortened to 10 clocks, and if it is less than 10 clocks, it remains unchanged.\nNote: The lane light and the sidewalk light should be paired, when the lane light is green or yellow, the sidewalk light is red; When the lane light is red, the sidewalk light is green, and for the sake of simplicity, only the lane light is considered.", "Input": "`timescale 1ns/1ns\n\nmodule traffic_light\n    (\n\t\tinput rst_n, \n      input clk, \n      input pass_request,\n\t\t  output wire[7:0]clock,\n      output reg red,\n\t\t  output reg yellow,\n\t\t  output reg green\n    );\n\t\n\tparameter \tidle = 2'd0,\n\t\t\t\ts1_red = 2'd1,\n\t\t\t\ts2_yellow = 2'd2,\n\t\t\t\ts3_green = 2'd3;"}
{"Instruction": "Please act as a professional verilog designer.\n\nImplement a data width conversion circuit that converts 8-bit data input to 16-bit data output. The first arriving 8-bit data should be placed in the higher 8 bits of the 16-bit data output. ", "Input": "`timescale 1ns/1ns\nmodule width_8to16(\n\tinput \t\t\t\t   clk \t\t,   \n\tinput \t\t\t\t   rst_n\t\t,\n\tinput\t\t\t\t      valid_in\t,\n\tinput\t   [7:0]\t\t   data_in\t,\n \n \toutput\treg\t\t\tvalid_out,\n\toutput   reg [15:0]\tdata_out\n);"}
{"Instruction": "Please act as a professional verilog designer.\n\nImplement a module of a ripple 64 bit adder, which is divided into 4 sections to achieve 4-stage pipeline. ", "Input": "module adder_64bit\n#(\n    parameter           DATA_WIDTH = 64,\n    parameter           STG_WIDTH  = 16\n)\n(\n    input                               clk             ,\n    input                               rst_n           ,\n    input                               i_en            ,\n    input       [DATA_WIDTH-1:0]        adda            ,\n    input       [DATA_WIDTH-1:0]        addb            ,\n    output      [DATA_WIDTH:0]          result          ,\n    output reg                          o_en            \n);"}
{"Instruction": "Please act as a professional verilog designer.\n\nImplement an ALU for 32bit MIPS-ISA CPU. The \u201ca\u201d and \u201cb\u201d are the two oprands of the ALU, the \u201caluc\u201d is the opcode, the \u201cr\u201d gives out the result. \u201czero\u201d means if the result is zero, \u201ccarry\u201d means if there is a carry bit, \u201cnegative\u201d means if the result is negative, \u201coverflow\u201d means if the computation is overflow, the \u201cflag\u201d is the result of \u201cslt\u201d and \u201csltu\u201d instructions. The supported operations and corresponding opcode are shown below:\n    parameter ADD = 6'b100000;\n    parameter ADDU = 6'b100001;\n    parameter SUB = 6'b100010;\n    parameter SUBU = 6'b100011;\n    parameter AND = 6'b100100;\n    parameter OR = 6'b100101;\n    parameter XOR = 6'b100110;\n    parameter NOR = 6'b100111;\n    parameter SLT = 6'b101010;\n    parameter SLTU = 6'b101011;\n    parameter SLL = 6'b000000;\n    parameter SRL = 6'b000010;\n    parameter SRA = 6'b000011;\n    parameter SLLV = 6'b000100;\n    parameter SRLV = 6'b000110;\n    parameter SRAV = 6'b000111;\n    parameter LUI = 6'b001111;", "Input": "module alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n    );\n    \n\n    parameter ADD = 6'b100000;\n    parameter ADDU = 6'b100001;\n    parameter SUB = 6'b100010;\n    parameter SUBU = 6'b100011;\n    parameter AND = 6'b100100;\n    parameter OR = 6'b100101;\n    parameter XOR = 6'b100110;\n    parameter NOR = 6'b100111;\n    parameter SLT = 6'b101010;\n    parameter SLTU = 6'b101011;\n    parameter SLL = 6'b000000;\n    parameter SRL = 6'b000010;\n    parameter SRA = 6'b000011;\n    parameter SLLV = 6'b000100;\n    parameter SRLV = 6'b000110;\n    parameter SRAV = 6'b000111;\n    parameter JR = 6'b001000;\n    \n    parameter LUI = 6'b001111;"}
{"Instruction": "Please act as a professional verilog designer.\n\nImplement a 16-bit divider module, dividend is 16-bit and divider is 8-bit. Extract the higher bits of the dividend, matching the bit width of the divisor. Compare these bits with the divisor: if the dividend bits are greater, set the quotient to 1, otherwise set it to 0, and use the difference as the remainder. Concatenate the remainder with the highest remaining 1-bit of the dividend, and repeat the process until all dividend bits are processed.", "Input": "module div_16bit(\n    input wire [15:0] A,\n    input wire [7:0] B,\n    output wire [15:0] result,\n    output wire [15:0] odd\n    );"}
{"Instruction": "Please act as a professional verilog designer.\n\nImplement the design of unsigned 16bit multiplier based on shifting and adding opration. ", "Input": "module multi_16bit(\n    clk, \n    rst_n,\n    start, \n    ain, \n    bin, \n    yout, \n    done\n);\n\ninput clk;        // Chip clock signal.\ninput rst_n;      // Active-low reset signal. Defined as 0 for chip reset; defined as 1 for reset signal inactive.\ninput start;      // Chip enable signal. \ninput [15:0] ain; // Input a (multiplicand) with a data width of 16 bits.\ninput [15:0] bin; // Input b (multiplier) with a data width of 16 bits.\n\noutput [31:0] yout; // Product output with a data width of 32 bits.\noutput done;      // Chip output flag signal. Defined as 1 indicates multiplication operation completion."}
{"Instruction": "Please act as a professional verilog designer.\n\nImplement the design of unsigned 8bit multiplier based on pipelining processing. ", "Input": "module multi_pipe_8bit#(\n    parameter size = 8\n)(\n          clk,      \n          rst_n,       \n          mul_a,       \n          mul_b, \n          mul_en_in,\n \n          mul_en_out,      \n          mul_out    \n);\n \n   input clk;           \n   input rst_n; \n   input mul_en_in;      \n   input [size-1:0] mul_a;       \n   input [size-1:0] mul_b;       \n \n   output reg mul_en_out;  \n   output reg [size*2-1:0] mul_out;    "}
{"Instruction": "Please act as a professional verilog designer.\n\nImplement a Multiplying Accumulator for 32bit integer. In the MAC_PE, there is a register that stores the partial sum (the intermediate accumulation result), and in each cycle, the result of \u201ca multiplied by b\u201d will be accumulated in this register, and the \u201cc\u201d shows the value of the register.", "Input": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n\n    output [31:0] c\n);"}
